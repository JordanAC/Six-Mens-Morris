( defclass piece () 
 (
  ( color :accessor piece-color :initarg :color :initform 'white )
  ( number :accessor piece-number :initarg :number :initform 1)
 )
)

( defmethod establish-pieces ()
 ( setf *wp1* ( make-instance 'piece ) )
 ( setf ( get 'representation *wp1* ) 'w )
 ( setf *wp2* ( make-instance 'piece :number 2 ) )
 ( setf ( get 'representation *wp2* ) 'w )
 ( setf *wp3* ( make-instance 'piece :number 3 ) )
 ( setf ( get 'representation *wp3* ) 'w )
 ( setf *wp4* ( make-instance 'piece :number 4 ) )
 ( setf ( get 'representation *wp4* ) 'w )
 ( setf *wp5* ( make-instance 'piece :number 5 ) )
 ( setf ( get 'representation *wp5* ) 'w )
 ( setf *wp6* ( make-instance 'piece :number 6 ) )
 ( setf ( get 'representation *wp6* ) 'w )
 ( setf *bp1* ( make-instance 'piece :color 'black ) )
 ( setf ( get 'representation *bp1* ) 'b )
 ( setf *bp2* ( make-instance 'piece :color 'black :number 2 ) )
 ( setf ( get 'representation *bp2* ) 'b )
 ( setf *bp3* ( make-instance 'piece :color 'black :number 3 ) )
 ( setf ( get 'representation *bp3* ) 'b )
 ( setf *bp4* ( make-instance 'piece :color 'black :number 4 ) )
 ( setf ( get 'representation *bp4* ) 'b )
 ( setf *bp5* ( make-instance 'piece :color 'black :number 5 ) )
 ( setf ( get 'representation *bp5* ) 'b )
 ( setf *bp6* ( make-instance 'piece :color 'black :number 6 ) )
 ( setf ( get 'representation *bp6* ) 'b )
 ( setf *wpieces* (list *wp1* *wp2* *wp3* *wp4* *wp5* *wp6*))
 ( setf *bpieces* (list *bp1* *bp2* *bp3* *bp4* *bp5* *bp6*))
)

( defmethod display-piece ( ( p piece ) )
 ( format t "Piece color: ~A , number ~A~%" (piece-color p) (piece-number p) )
)

( defmethod to-string ( ( p piece ) )
 ( get 'representation p )
)

( defmethod all-to-string ( ( l list ) )
 ( mapcar #'to-string l )
)

( defmethod is-white-p ( ( p piece ) )
 ( equal ( piece-color p ) 'white )
)

( defmethod is-black-p ( ( p piece ) )
 ( equal ( piece-color p ) 'black )
)

( defmethod display-piece-demo ()
 ( setf p1 ( make-instance 'piece ) )
 ( setf p2 ( make-instance 'piece :color 'black ) )
 ( display-piece p1 )
 ( display-piece p2 )
)

( defmethod representation-demo ()
 ( establish-pieces )
 ( format t "*wp1* ~A~%" ( get 'representation *wp1*  ) )
 nil
)

( defmethod to-string-demo ()
 ( establish-pieces )
 ( format t "~A~%" ( write-to-string ( mapcar #'to-string *wpieces* ) ) )
 ( format t "*wp1* ~A~%" ( to-string *wp1* ) )
 nil
)

( defclass board ()
 (
  ( s1 :accessor board-s1 :initarg :s1 :initform 's )
  ( s2 :accessor board-s2 :initarg :s2 :initform 's )
  ( s3 :accessor board-s3 :initarg :s3 :initform 's )
  ( s4 :accessor board-s4 :initarg :s4 :initform 's )
  ( s5 :accessor board-s5 :initarg :s5 :initform 's )
  ( s6 :accessor board-s6 :initarg :s6 :initform 's )
  ( s7 :accessor board-s7 :initarg :s7 :initform 's )
  ( s8 :accessor board-s8 :initarg :s8 :initform 's )
  ( s9 :accessor board-s9 :initarg :s9 :initform 's )
  ( s10 :accessor board-s10 :initarg :s10 :initform 's )
  ( s11 :accessor board-s11 :initarg :s11 :initform 's )
  ( s12 :accessor board-s12 :initarg :s12 :initform 's )
  ( s13 :accessor board-s13 :initarg :s13 :initform 's )
  ( s14 :accessor board-s14 :initarg :s14 :initform 's )
  ( s15 :accessor board-s15 :initarg :s15 :initform 's )
  ( s16 :accessor board-s16 :initarg :s16 :initform 's )
 )
)

( defmethod display-board ((b board))
 ( format t "~A1----------------- ~A2 -----------------~A3~%" (board-s1 b) (board-s2 b) (board-s3 b) )
 ( format t "|                   |                    | ~%" )
 ( format t "|                   |                    | ~%" )
 ( format t "|         ~AA------- ~AB -------~AC         | ~%" (board-s10 b) (board-s11 b) (board-s12 b) )
 ( format t "|         |                   |          | ~%" )
 ( format t "|         |                   |          | ~%" )
 ( format t "~A8------- ~A9                  ~AD--------~A4 ~%" (board-s8 b) (board-s9 b) (board-s13 b) (board-s4 b) )
 ( format t "|         |                   |          | ~%" )
 ( format t "|         |                   |          | ~%" )
 ( format t "|         ~AG------- ~AF ------ ~AE         | ~%" (board-s16 b) (board-s15 b) (board-s14 b) )
 ( format t "|                   |                    | ~%" )
 ( format t "|                   |                    | ~%" )
 ( format t "~A7----------------- ~A6 -----------------~A5~%" (board-s7 b) (board-s6 b) (board-s5 b) )
)

( defmethod board-w-pieces ((b board))
 ( setf (board-s1 b) 'w )
 ( setf (board-s2 b) 'w )
 ( setf (board-s3 b) 'b )
 ( setf (board-s4 b) 'w )
 ( setf (board-s5 b) 'w )
 ( setf (board-s6 b) 'w )
 ( setf (board-s7 b) 'b )
 ( setf (board-s8 b) 'b )
 ( setf (board-s9 b) 'w )
 ( setf (board-s10 b) 'b )
 ( setf (board-s11 b) 'b )
 ( setf (board-s12 b) 'b )
)

( defmethod display-board-demo ()
 ( setf *board* (make-instance 'board) )
 ( format t "Empty board...~%" )
 ( display-board *board*)
 ( format t "~%" )
 ( format t "Board with pieces...~%" )
 (format t "~%" )
 ( board-w-pieces *board* )
 ( display-board *board*)
)

( defmethod avail-spots ( (b board) &aux spaces )
 ( if (eq (board-s1 b) 's ) ( setf spaces (append spaces (list 's1) ) ) )
 ( if (eq (board-s2 b) 's ) ( setf spaces (append spaces (list 's2) ) ) )
 ( if (eq (board-s3 b) 's ) ( setf spaces (append spaces (list 's3) ) ) )
 ( if (eq (board-s4 b) 's ) ( setf spaces (append spaces (list 's4) ) ) )
 ( if (eq (board-s5 b) 's ) ( setf spaces (append spaces (list 's5) ) ) )
 ( if (eq (board-s6 b) 's ) ( setf spaces (append spaces (list 's6) ) ) )
 ( if (eq (board-s7 b) 's ) ( setf spaces (append spaces (list 's7) ) ) )
 ( if (eq (board-s8 b) 's ) ( setf spaces (append spaces (list 's8) ) ) )
 ( if (eq (board-s9 b) 's ) ( setf spaces (append spaces (list 's9) ) ) )
 ( if (eq (board-s10 b) 's ) ( setf spaces (append spaces (list 'sA) ) ) )
 ( if (eq (board-s11 b) 's ) ( setf spaces (append spaces (list 'sB) ) ) )
 ( if (eq (board-s12 b) 's ) ( setf spaces (append spaces (list 'sC) ) ) )
 ( if (eq (board-s13 b) 's ) ( setf spaces (append spaces (list 'sD) ) ) )
 ( if (eq (board-s14 b) 's ) ( setf spaces (append spaces (list 'sE) ) ) )
 ( if (eq (board-s15 b) 's ) ( setf spaces (append spaces (list 'sF) ) ) )
 ( if (eq (board-s16 b) 's ) ( setf spaces (append spaces (list 'sG) ) ) )
  spaces
)

( defclass player ()
 (
  ( name :accessor player-name :initarg :name )
 )
)

( defclass human-player ( player ) () )

( defclass r-machine-player ( player ) () )

( defclass h-machine-player ( player ) () )

( defclass state()
 (
  ( board :accessor state-board :initarg :board :initform ( make-instance 'board) )
  ( player :accessor state-player :initarg :player :initform nil ) 
  )
)

( defmethod display (( p player) )
 ( format t "Player Name is ~A~%" ( player-name p) )
)

( defmethod display (( s state) )
 ( display-board (state-board s) )
 ( format t "Current Player is ~A~%" ( player-name (state-player s) ) )
)

( defclass game()
 (
  ( state :accessor game-state :initarg :state)
  ( player1 :accessor game-player1 :initarg :player1)
  ( player2 :accessor game-player2 :initarg :player2)
 )
)

( defmethod pick-first-player ( (p player) (q player) )
 ( setf playerlist ( list ( player-name p ) ( player-name q ) ) )
 ( setf name ( nth (random (length playerlist) ) playerlist) ) 
 ( if (eq name (player-name p) )
	p
	q
 )
)

( defmethod change-player ( (g game) )
 (let (state p1 p2 current-player next-player)
    (setf state (game-state g) )
	(setf p1 (game-player1 g) )
	(setf p2 (game-player2 g) )
	(setf current-player (state-player state) )
	( if (equal-player current-player p1) 
	     (setf next-player p2)
		 (setf next-player p1) )
    (setf (state-player state) next-player) 
	(format t "~A , it is your turn ~%" (player-name next-player))
	) 
)

( defmethod current-player ( (g game) )
 (state-player (game-state g) )
)
	
( defmethod equal-player ((p player) (q player) )
 (eq (player-name p) (player-name q) )
)

( defmethod other-player ((g game))
 ( if (equal-player (state-player (game-state g)) (game-player1 g))
	  (game-player2 g)
	  (game-player1 g)
 )
)

( defmethod change-piece-set ()
 (setf wp *wavail*)
 (setf bp *bavail*)
 (if (eq *current-pieces* wp)
	 (setf *current-pieces* bp)
	 (setf *current-pieces* wp)
 )
)

( defmethod change-player-board ()
 (setf wb *used-spots-w*)
 (setf bb *used-spots-b*)
 (if (eq *current-player-board* wb)
	 (setf *current-player-board* bb)
	 (setf *current-player-board* wb)
 )
)

( defmethod display-current-piece-set ()
 ( format t "Your pieces are ~A~%" *current-pieces*  )
)

( defmethod display-current-player-board ()
 ( format t "Your used spots are ~A~%" *current-player-board* )
)

( defmethod select-piece ()
 ( format t "Please select a piece ~%" )
 ( setf p ( read ) )
 ( cond 
    ( (null p)
	  ( format t "please pick another piece~%" )
	  ( select-piece )
	)
	(t p)
 )
)

;;human player to select location
( defmethod select-spot ( (b board) )
 (let (spot avail-spots)
    (setf avail-spots (avail-spots b) )
	(format t "Where to play piece? ~A~%" avail-spots)
	(setf spot (read))
	(cond
	  ((not (member spot avail-spots))
	    (format t "That spot is taken. Select another~%")
		(select-spot b))
		(t spot)
    )
 )
)

( defmethod place-piece-on-board ( (s symbol) (b board) &aux spot )
 ( setf spot (select-spot b) )
 ( put-piece spot s b )
 ( remove-piece-from-set s )
)

( defmethod set-used-spots ( (b board) )
 ( setf *used-spots-w* () )
 ( setf *used-spots-b* () )
    (if ( eq (board-s1 b) 'w ) (setf *used-spots-w* ( append (list 's1) *used-spots-w* ) ) )
	(if ( eq (board-s2 b) 'w ) (setf *used-spots-w* ( append (list 's2) *used-spots-w* ) ) )
    (if ( eq (board-s3 b) 'w ) (setf *used-spots-w* ( append (list 's3) *used-spots-w* ) ) )
    (if ( eq (board-s4 b) 'w ) (setf *used-spots-w* ( append (list 's4) *used-spots-w* ) ) )
    (if ( eq (board-s5 b) 'w ) (setf *used-spots-w* ( append (list 's5) *used-spots-w* ) ) )
    (if ( eq (board-s6 b) 'w ) (setf *used-spots-w* ( append (list 's6) *used-spots-w* ) ) )
    (if ( eq (board-s7 b) 'w ) (setf *used-spots-w* ( append (list 's7) *used-spots-w* ) ) )
    (if ( eq (board-s8 b) 'w ) (setf *used-spots-w* ( append (list 's8) *used-spots-w* ) ) )
    (if ( eq (board-s9 b) 'w ) (setf *used-spots-w* ( append (list 's9) *used-spots-w* ) ) )
    (if ( eq (board-s10 b) 'w ) (setf *used-spots-w* ( append (list 'sA) *used-spots-w* ) ) )
    (if ( eq (board-s11 b) 'w ) (setf *used-spots-w* ( append (list 'sB) *used-spots-w* ) ) )
    (if ( eq (board-s12 b) 'w ) (setf *used-spots-w* ( append (list 'sC) *used-spots-w* ) ) )
    (if ( eq (board-s13 b) 'w ) (setf *used-spots-w* ( append (list 'sD) *used-spots-w* ) ) )
    (if ( eq (board-s14 b) 'w ) (setf *used-spots-w* ( append (list 'sE) *used-spots-w* ) ) )
    (if ( eq (board-s15 b) 'w ) (setf *used-spots-w* ( append (list 'sF) *used-spots-w* ) ) )
    (if ( eq (board-s16 b) 'w ) (setf *used-spots-w* ( append (list 'sG) *used-spots-w* ) ) )
    (if ( eq (board-s1 b) 'b ) (setf *used-spots-b* ( append (list 's1) *used-spots-b* ) ) )
    (if ( eq (board-s2 b) 'b ) (setf *used-spots-b* ( append (list 's2) *used-spots-b* ) ) )
    (if ( eq (board-s3 b) 'b ) (setf *used-spots-b* ( append (list 's3) *used-spots-b* ) ) )
    (if ( eq (board-s4 b) 'b ) (setf *used-spots-b* ( append (list 's4) *used-spots-b* ) ) )
    (if ( eq (board-s5 b) 'b ) (setf *used-spots-b* ( append (list 's5) *used-spots-b* ) ) )
    (if ( eq (board-s6 b) 'b ) (setf *used-spots-b* ( append (list 's6) *used-spots-b* ) ) )
    (if ( eq (board-s7 b) 'b ) (setf *used-spots-b* ( append (list 's7) *used-spots-b* ) ) )
    (if ( eq (board-s8 b) 'b ) (setf *used-spots-b* ( append (list 's8) *used-spots-b* ) ) )
    (if ( eq (board-s9 b) 'b ) (setf *used-spots-b* ( append (list 's9) *used-spots-b* ) ) )
    (if ( eq (board-s10 b) 'b ) (setf *used-spots-b* ( append (list 'sA) *used-spots-b* ) ) )
    (if ( eq (board-s11 b) 'b ) (setf *used-spots-b* ( append (list 'sB) *used-spots-b* ) ) )
    (if ( eq (board-s12 b) 'b ) (setf *used-spots-b* ( append (list 'sC) *used-spots-b* ) ) )
    (if ( eq (board-s13 b) 'b ) (setf *used-spots-b* ( append (list 'sD) *used-spots-b* ) ) )
    (if ( eq (board-s14 b) 'b ) (setf *used-spots-b* ( append (list 'sE) *used-spots-b* ) ) )
    (if ( eq (board-s15 b) 'b ) (setf *used-spots-b* ( append (list 'sF) *used-spots-b* ) ) )
    (if ( eq (board-s16 b) 'b ) (setf *used-spots-b* ( append (list 'sG) *used-spots-b* ) ) )
)

;;remove spot from other players list of used spots
( defmethod update-other-player-board((s symbol))
 (if (eq *current-player-board* *used-spots-w*) 
	(setf *used-spots-b* (remove s *used-spots-b*) )
	(setf *used-spots-w* (remove s *used-spots-w*) )
 )
)

( defmethod remove-piece-from-board ((b board)(p player))
 ( format t "~A, Select a spot to remove piece from~%" (player-name p) )
 ( setf spot (read) )
 ( cond
    ( (eq spot 's1 ) (setf (board-s1 b) 's) (update-other-player-board spot) )
	( (eq spot 's2 ) (setf (board-s2 b) 's) (update-other-player-board spot) )
	( (eq spot 's3 ) (setf (board-s3 b) 's) (update-other-player-board spot) )
	( (eq spot 's4 ) (setf (board-s4 b) 's) (update-other-player-board spot) )
	( (eq spot 's5 ) (setf (board-s5 b) 's) (update-other-player-board spot) )
	( (eq spot 's6 ) (setf (board-s6 b) 's) (update-other-player-board spot) )
	( (eq spot 's7 ) (setf (board-s7 b) 's) (update-other-player-board spot) )
	( (eq spot 's8 ) (setf (board-s8 b) 's) (update-other-player-board spot) )
	( (eq spot 's9 ) (setf (board-s9 b) 's) (update-other-player-board spot) )
	( (eq spot 'sA ) (setf (board-s10 b) 's) (update-other-player-board spot) )
	( (eq spot 'sB ) (setf (board-s11 b) 's) (update-other-player-board spot) )
	( (eq spot 'sC ) (setf (board-s12 b) 's) (update-other-player-board spot) )
	( (eq spot 'sD ) (setf (board-s13 b) 's) (update-other-player-board spot) )
	( (eq spot 'sE ) (setf (board-s14 b) 's) (update-other-player-board spot) )
	( (eq spot 'sF ) (setf (board-s15 b) 's) (update-other-player-board spot) )
	( (eq spot 'sG ) (setf (board-s16 b) 's) (update-other-player-board spot) )
 )
)

( defmethod remove-from-board-p ((b board)(p player)(s symbol))
 ( cond
   ( (three-in-a-row-w b s)  
    ( remove-piece-from-board b p ) )
   ( (three-in-a-row-b b s)
    ( remove-piece-from-board b p )	)
 )
)

( defmethod remove-piece-from-set ( (s symbol) )
 (cond 
  ( (eq *current-pieces* *wavail*)
	 (setf *current-pieces* (remove s *current-pieces* :count 1) )
	 (setf *wavail* *current-pieces* )
    )
  ( (eq *current-pieces* *bavail*) 
     (setf *current-pieces* (remove s *current-pieces* :count 1 ) )
	 (setf *bavail* *current-pieces* )
	)
 )
)

( defmethod update-player-board ( (s1 symbol) (s2 symbol) )
 (cond
  ( (eq *current-player-board* *used-spots-w*)
	 (setf *current-player-board* (append (list s2) *current-player-board*) )
	 (setf *current-player-board* (remove s1 *current-player-board*) )
	 (setf *used-spots-w* *current-player-board* )
  )
  ( (eq *current-player-board* *used-spots-b*)
	 (setf *current-player-board* (append (list s2) *current-player-board*) )
	 (setf *current-player-board* (remove s1 *current-player-board*) )
	 (setf *used-spots-b* *current-player-board* )
  )
 )
)

( defmethod put-piece ( (spot symbol)(s symbol)(b board) )
 ( format t "Placing piece ~A on ~A~%" s spot )
 ( cond
    ( (eq spot 's1) (setf (board-s1 b) s ) )
	( (eq spot 's2) (setf (board-s2 b) s ) )
	( (eq spot 's3) (setf (board-s3 b) s ) )
	( (eq spot 's4) (setf (board-s4 b) s ) )
	( (eq spot 's5) (setf (board-s5 b) s ) )
	( (eq spot 's6) (setf (board-s6 b) s ) )
	( (eq spot 's7) (setf (board-s7 b) s ) )
	( (eq spot 's8) (setf (board-s8 b) s ) )
	( (eq spot 's9) (setf (board-s9 b) s ) )
	( (eq spot 'sA) (setf (board-s10 b) s ) )
	( (eq spot 'sB) (setf (board-s11 b) s ) )
	( (eq spot 'sC) (setf (board-s12 b) s ) )
	( (eq spot 'sD) (setf (board-s13 b) s ) )
	( (eq spot 'sE) (setf (board-s14 b) s ) )
	( (eq spot 'sF) (setf (board-s15 b) s ) )
	( (eq spot 'sG) (setf (board-s16 b) s ) )
 )
)

( defmethod game-over-p((g game))
 ( cond
    ( ( all-pieces-used ) 
	  (or (eq (length *current-player-board*) 2 )
	      (no-legal-moves *current-player-board* (state-board (game-state g) ))
	  )
	)
 )
)

( defmethod no-legal-moves ((lst list)(b board))
(cond
( (null lst)
t
)
((has-avail-adj-spot (car lst) b)
nil)
(t
 t
(no-legal-moves (cdr lst) b)
)
)
)

( defmethod three-in-a-row-w ( (b board) (s symbol) )
 ( cond
  ( ( and (or (eq s 's1)(eq s 's2)(eq s 's3) ) (eq (board-s1 b) 'w)
      (eq (board-s2 b) 'w )
      (eq (board-s3 b) 'w )		   
  ) t)
  ( ( and (or (eq s 's1)(eq s 's7)(eq s 's8) ) (eq (board-s1 b) 'w )
      (eq (board-s7 b) 'w )
      (eq (board-s8 b) 'w )		   
  ) t)
  ( ( and (or (eq s 's3)(eq s 's4)(eq s 's5) ) (eq (board-s3 b) 'w )
      (eq (board-s4 b) 'w )
      (eq (board-s5 b) 'w )		   
  ) t)
  ( ( and (or (eq s 's5)(eq s 's6)(eq s 's7) ) (eq (board-s5 b) 'w )
      (eq (board-s6 b) 'w )
      (eq (board-s7 b) 'w )		   
  ) t)
  ( ( and (or (eq s 'sA)(eq s 'sB)(eq s 'sC) ) (eq (board-s10 b) 'w )
      (eq (board-s11 b) 'w )
      (eq (board-s12 b) 'w )		   
  ) t)
  ( ( and (or (eq s 'sC)(eq s 'sD)(eq s 'sE) ) (eq (board-s12 b) 'w )
      (eq (board-s13 b) 'w )
      (eq (board-s14 b) 'w )		   
  ) t)
  ( ( and (or (eq s 'sE)(eq s 'sF)(eq s 'sG) ) (eq (board-s14 b) 'w )
      (eq (board-s15 b) 'w )
      (eq (board-s16 b) 'w )		   
  ) t)
  ( ( and (or (eq s 'sA)(eq s 's9)(eq s 'sG) ) (eq (board-s10 b) 'w )
      (eq (board-s9 b) 'w )
      (eq (board-s16 b) 'w )		   
  ) t)
 )
)

( defmethod three-in-a-row-b ( (b board) (s symbol) )
 ( cond
  ( ( and (or (eq s 's1)(eq s 's2)(eq s 's3) ) (eq (board-s1 b) 'b )
      (eq (board-s2 b) 'b )
      (eq (board-s3 b) 'b )		   
  ) t)
  ( ( and (or (eq s 's1)(eq s 's7)(eq s 's8) ) (eq (board-s1 b) 'b )
      (eq (board-s7 b) 'b )
      (eq (board-s8 b) 'b )		   
  ) t)
  ( ( and (or (eq s 's3)(eq s 's4)(eq s 's5) ) (eq (board-s3 b) 'b )
      (eq (board-s4 b) 'b )
      (eq (board-s5 b) 'b )		   
  ) t)
  ( ( and (or (eq s 's5)(eq s 's6)(eq s 's7) ) (eq (board-s5 b) 'b )
      (eq (board-s6 b) 'b )
      (eq (board-s7 b) 'b )		   
  ) t)
  ( ( and (or (eq s 'sA)(eq s 'sB)(eq s 'sC) ) (eq (board-s10 b) 'b )
      (eq (board-s11 b) 'b )
      (eq (board-s12 b) 'b )		   
  ) t)
  ( ( and (or (eq s 'sC)(eq s 'sD)(eq s 'sE) ) (eq (board-s12 b) 'b )
      (eq (board-s13 b) 'b )
      (eq (board-s14 b) 'b )		   
  ) t)
  ( ( and (or (eq s 'sE)(eq s 'sF)(eq s 'sG) ) (eq (board-s14 b) 'b )
      (eq (board-s15 b) 'b )
      (eq (board-s16 b) 'b )		   
  ) t)
  ( ( and (or (eq s 'sA)(eq s 's9)(eq s 'sG) ) (eq (board-s10 b) 'b )
      (eq (board-s9 b) 'b )
      (eq (board-s16 b) 'b )		   
  ) t)
 )
)

( defmethod get-piece-at-spot ((b board) (s symbol) &aux piece )
    (if (eq s 's1) (setf piece (board-s1 b) ) )
	(if (eq s 's2) (setf piece (board-s2 b) ) )
	(if (eq s 's3) (setf piece (board-s3 b) ) )
	(if (eq s 's4) (setf piece (board-s4 b) ) )
	(if (eq s 's5) (setf piece (board-s5 b) ) )
	(if (eq s 's6) (setf piece (board-s6 b) ) )
	(if (eq s 's7) (setf piece (board-s7 b) ) )
	(if (eq s 's8) (setf piece (board-s8 b) ) )
	(if (eq s 's9) (setf piece (board-s9 b) ) )
	(if (eq s 'sA) (setf piece (board-s10 b) ) )
	(if (eq s 'sB) (setf piece (board-s11 b) ) )
	(if (eq s 'sC) (setf piece (board-s12 b) ) )
	(if (eq s 'sD) (setf piece (board-s13 b) ) )
	(if (eq s 'sE) (setf piece (board-s14 b) ) )
	(if (eq s 'sF) (setf piece (board-s15 b) ) )
	(if (eq s 'sG) (setf piece (board-s16 b) ) )
 piece
)

( defmethod slide-piece ( (s1 symbol) (s2 symbol) (b board) )
 ( format t "Sliding piece from ~A to ~A~%" s1 s2 )
 ( cond
  ( (eq s2 's1) (setf (board-s1 b) (get-piece-at-spot b s1)) (set-original-spot s1 b) )
  ( (eq s2 's2) (setf (board-s2 b) (get-piece-at-spot b s1)) (set-original-spot s1 b) )
  ( (eq s2 's3) (setf (board-s3 b) (get-piece-at-spot b s1)) (set-original-spot s1 b) )
  ( (eq s2 's4) (setf (board-s4 b) (get-piece-at-spot b s1)) (set-original-spot s1 b) )
  ( (eq s2 's5) (setf (board-s5 b) (get-piece-at-spot b s1)) (set-original-spot s1 b) )
  ( (eq s2 's6) (setf (board-s6 b) (get-piece-at-spot b s1)) (set-original-spot s1 b) )
  ( (eq s2 's7) (setf (board-s7 b) (get-piece-at-spot b s1)) (set-original-spot s1 b) )
  ( (eq s2 's8) (setf (board-s8 b) (get-piece-at-spot b s1)) (set-original-spot s1 b) )
  ( (eq s2 's9) (setf (board-s9 b) (get-piece-at-spot b s1)) (set-original-spot s1 b) )
  ( (eq s2 'sA) (setf (board-s10 b) (get-piece-at-spot b s1)) (set-original-spot s1 b) )
  ( (eq s2 'sB) (setf (board-s11 b) (get-piece-at-spot b s1)) (set-original-spot s1 b) )
  ( (eq s2 'sC) (setf (board-s12 b) (get-piece-at-spot b s1)) (set-original-spot s1 b) )
  ( (eq s2 'sD) (setf (board-s13 b) (get-piece-at-spot b s1)) (set-original-spot s1 b) )
  ( (eq s2 'sE) (setf (board-s14 b) (get-piece-at-spot b s1)) (set-original-spot s1 b) )
  ( (eq s2 'sF) (setf (board-s15 b) (get-piece-at-spot b s1)) (set-original-spot s1 b) )
  ( (eq s2 'sG) (setf (board-s16 b) (get-piece-at-spot b s1)) (set-original-spot s1 b) )
 )
)

( defmethod set-original-spot ((s symbol)(b board))
 ( cond
  ( (eq s 's1) (setf (board-s1 b) 's) )
  ( (eq s 's2) (setf (board-s2 b) 's) )
  ( (eq s 's3) (setf (board-s3 b) 's) )
  ( (eq s 's4) (setf (board-s4 b) 's) )
  ( (eq s 's5) (setf (board-s5 b) 's) )
  ( (eq s 's6) (setf (board-s6 b) 's) )
  ( (eq s 's7) (setf (board-s7 b) 's) )
  ( (eq s 's8) (setf (board-s8 b) 's) )
  ( (eq s 's9) (setf (board-s9 b) 's) )
  ( (eq s 'sA) (setf (board-s10 b) 's) )
  ( (eq s 'sB) (setf (board-s11 b) 's) )
  ( (eq s 'sC) (setf (board-s12 b) 's) )
  ( (eq s 'sD) (setf (board-s13 b) 's) )
  ( (eq s 'sE) (setf (board-s14 b) 's) )
  ( (eq s 'sF) (setf (board-s15 b) 's) )
  ( (eq s 'sG) (setf (board-s16 b) 's) )
 )
)

( defmethod adjacent-p ( (s1 symbol) (s2 symbol) )
 ( cond 
  ( ( and (eq s1 's1)
		    (or	(eq s2 's2)
				(eq s2 's8)
			)
	)
	t
 )
 ( ( and (eq s1 's2)
		    (or	(eq s2 's1)
				(eq s2 's3)
				(eq s2 'sB)
			)
	)
	t
 )
  ( ( and (eq s1 's3)
		    (or	(eq s2 's2)
				(eq s2 's4)
			)
	)
	t
 )
 ( ( and (eq s1 's4)
		    (or	(eq s2 's3)
				(eq s2 's5)
				(eq s2 'sD)
			)
	)
	t
 )
( ( and (eq s1 's5)
		    (or	(eq s2 's4)
				(eq s2 's6)
			)
	)
	t
 )
 ( ( and (eq s1 's6)
		    (or	(eq s2 's5)
				(eq s2 's7)
				(eq s2 'sF)
			)
	)
	t
 )
  ( ( and (eq s1 's7)
		    (or	(eq s2 's6)
				(eq s2 's8)
			)
	)
	t
 )
 ( ( and (eq s1 's8)
		    (or	(eq s2 's1)
				(eq s2 's7)
				(eq s2 's9)
			)
	)
	t
 )
( ( and (eq s1 's9)
		    (or	(eq s2 's8)
				(eq s2 'sA)
				(eq s2 'sG)
			)
	)
	t
 )
 ( ( and (eq s1 'sA)
		    (or	(eq s2 's9)
				(eq s2 'sB)
			)
	)
	t
 )
  ( ( and (eq s1 'sB)
		    (or	(eq s2 's2)
				(eq s2 'sA)
				(eq s2 'sC)
			)
	)
	t
 )
 ( ( and (eq s1 'sC)
		    (or	(eq s2 'sB)
				(eq s2 'sD)
			)
	)
	t
 )
( ( and (eq s1 'sD)
		    (or	(eq s2 's4)
				(eq s2 'sC)
				(eq s2 'sE)
			)
	)
	t
 )
 ( ( and (eq s1 'sE)
		    (or	(eq s2 'sD)
				(eq s2 'sF)
			)
	)
	t
 )
  ( ( and (eq s1 'sF)
		    (or	(eq s2 's6)
				(eq s2 'sE)
				(eq s2 'sG)
			)
	)
	t
 )
 ( ( and (eq s1 'sG)
		    (or	(eq s2 's9)
				(eq s2 'sF)
			)
	)
	t
 )
 )
)

( defmethod make-move ((g game))
 ( display-current-piece-set )
 ( setf piece (select-piece) )
 ( place-piece-on-board piece ( state-board (game-state g) ) )
 nil
)

( defmethod move ( (g game) )
 ( make-move g )
 ( change-piece-set )
 ( change-player g )
)

( defmethod move-phase2 ( (g game) )
 ( phase-2 g )
 ( change-player-board )
 ( change-player g )
)

( defmethod play ( ( g game ) )
 ( loop
  ( terpri )
  ( display-board ( state-board ( game-state g ) ) )
  ( terpri )
  ( move g )
  ( cond 
   ( ( all-pieces-used )
     ( return-from play(play-phase2 g))
   )
  )
 )
)

( defmethod play-phase2 ( (g game) )
( format t "Entering Phase 2...~%" )
( set-used-spots (state-board (game-state g) ) )
( setf *current-player-board* *used-spots-w* )
 ( loop
    ( terpri )
	( display-board (state-board (game-state g) ) )
	( terpri )
	( move-phase2 g )
	( if ( game-over-p g )
	     ( return-from play-phase2 (end-game g) )
	)	
 )
)

( defmethod all-pieces-used ()
 ( if ( eq *current-pieces* () )
 t
 )
)

( defmethod h-h-game()
 ( establish-pieces )
 ( setf *wavail* (all-to-string *wpieces*) )
 ( setf *bavail* (all-to-string *bpieces*) )
 ( setf *current-pieces* *wavail* )
 ( let (state player1 player2 name1 name2 first initial-state game)
    (princ "Player 1: Your Name? ") (setf name1 (read) )
    (princ "Player 2: Your Name? ") (setf name2 (read) ) 
	(setf player1 (make-instance 'human-player :name name1) )
	(setf player2 (make-instance 'human-player :name name2) )
	(setf first (pick-first-player player1 player2) )
	(format t "~A , You get to go first ~%" (player-name first) )
	(setf initial-state (make-instance 'state :player first) )
	(make-instance 'game 
	  :state initial-state :player1 player1 :player2 player2)
 )
)

( defmethod phase-2 ( (g game) ) 
 ( display-current-player-board )
 ( princ "Select a spot to slide from " ) ( setf spot1 (read) )
 ( princ "Select a spot to slide to " ) ( setf spot2 (read) )
 ( cond
    ( ( not (adjacent-p spot1 spot2 )) 
	  (format t "Please select an adjacent spot~%") 
	  ( phase-2 g)
	)
	( t
	  ( slide-piece spot1 spot2 (state-board (game-state g) ) )
	  ( remove-from-board-p (state-board (game-state g) ) (other-player g) spot2 )
	  ( update-player-board spot1 spot2 )
	)
 )
)

( defmethod end-game ( (g game) )
 ( setf p (other-player g) )
 ( format t "Congratulations ~A, You are the WINNER!~%" (player-name p) )
 nil
)

( defmethod play-demo ()
 ( setf g (h-h-game) )
 ( play g )
)

;;--------------------------------------------------------------------Random Machine---------------------------------------------------------------------------

;;random player to select spot to place piece
( defmethod select-spot-r ( (b board) )
 (setf locations (avail-spots b) )
 (nth (random (length locations)) locations)
)

;;random player picks spot for sliding
( defmethod select-used-spot ((b board))
 (setf locations (avail-spots b) )
 (setf spot (nth (random (length *current-player-board*)) *current-player-board*) )
 (if (has-avail-adj-spot spot b)
    spot
	(select-used-spot b)
 )
)

;;random player selects adjacent spot
( defmethod select-adjacent-spot ((s symbol)(b board))
 (setf locations (avail-spots b) )
 (setf spot (nth (random (length locations)) locations))
 (if (adjacent-p spot s) 
	spot
	(select-adjacent-spot s b)
 )
)

;;check to see if spot has available adjacent spaces
( defmethod has-avail-adj-spot ((s symbol)(b board))
 ( cond
  ( (and (eq s 's1)
			(or (eq (board-s2 b) 's )
			    (eq (board-s8 b) 's )
	       )
   )
   t
 )
 ( (and (eq s 's2)
			(or (eq (board-s1 b) 's )
			    (eq (board-s3 b) 's )
				(eq (board-s11 b) 's )
	       )
   )
   t
 )
 ( (and (eq s 's3)
			(or (eq (board-s2 b) 's )
			    (eq (board-s4 b) 's )
	       )
   )
   t
 )
 ( (and (eq s 's4)
			(or (eq (board-s5 b) 's )
			    (eq (board-s3 b) 's )
				(eq (board-s13 b) 's )
	       )
   )
   t
 )
 ( (and (eq s 's5)
			(or (eq (board-s6 b) 's )
			    (eq (board-s4 b) 's )
	       )
   )
   t
 )
 ( (and (eq s 's6)
			(or (eq (board-s7 b) 's )
			    (eq (board-s5 b) 's )
				(eq (board-s15 b) 's )
	       )
   )
   t
 )
 ( (and (eq s 's7)
			(or (eq (board-s6 b) 's )
			    (eq (board-s8 b) 's )
	       )
   )
   t
 )
 ( (and (eq s 's8)
			(or (eq (board-s1 b) 's )
			    (eq (board-s7 b) 's )
				(eq (board-s9 b) 's )
	       )
   )
   t
 )
 ( (and (eq s 's9)
			(or (eq (board-s8 b) 's )
			    (eq (board-s10 b) 's )
				(eq (board-s16 b) 's )
	       )
   )
   t
 )
 ( (and (eq s 'sA)
			(or (eq (board-s9 b) 's )
			    (eq (board-s11 b) 's )
	       )
   )
   t
 )
 ( (and (eq s 'sB)
			(or (eq (board-s2 b) 's )
			    (eq (board-s12 b) 's )
				(eq (board-s10 b) 's )
	       )
   )
   t
 )
 ( (and (eq s 'sC)
			(or (eq (board-s11 b) 's )
			    (eq (board-s13 b) 's )
	       )
   )
   t
 )
 ( (and (eq s 'sD)
			(or (eq (board-s12 b) 's )
			    (eq (board-s14 b) 's )
				(eq (board-s4 b) 's )
	       )
   )
   t
 )
 ( (and (eq s 'sE)
			(or (eq (board-s15 b) 's )
			    (eq (board-s13 b) 's )
	       )
   )
   t
 )
 ( (and (eq s 'sF)
			(or (eq (board-s14 b) 's )
			    (eq (board-s16 b) 's )
				(eq (board-s6 b) 's )
	       )
   )
   t
 )
 ( (and (eq s 'sG)
			(or (eq (board-s9 b) 's )
			    (eq (board-s15 b) 's )
	       )
   )
   
   
   t
 )
)
)
;;return other player board
( defmethod other-player-board()
 (if (eq *current-player-board* *used-spots-w*)
	*used-spots-b*
	*used-spots-w*
 )
)

;;remove piece from board randomly
( defmethod remove-piece-from-board-r ((b board)(p player))
 ( setf l (other-player-board) )
 ( setf spot (nth (random (length l )) l) )
 ( format t "~A is removing piece from ~A~%" (player-name p) spot )
 ( cond
    ( (eq spot 's1 ) (setf (board-s1 b) 's) (update-other-player-board spot) )
	( (eq spot 's2 ) (setf (board-s2 b) 's) (update-other-player-board spot) )
	( (eq spot 's3 ) (setf (board-s3 b) 's) (update-other-player-board spot) )
	( (eq spot 's4 ) (setf (board-s4 b) 's) (update-other-player-board spot) )
	( (eq spot 's5 ) (setf (board-s5 b) 's) (update-other-player-board spot) )
	( (eq spot 's6 ) (setf (board-s6 b) 's) (update-other-player-board spot) )
	( (eq spot 's7 ) (setf (board-s7 b) 's) (update-other-player-board spot) )
	( (eq spot 's8 ) (setf (board-s8 b) 's) (update-other-player-board spot) )
	( (eq spot 's9 ) (setf (board-s9 b) 's) (update-other-player-board spot) )
	( (eq spot 'sA ) (setf (board-s10 b) 's) (update-other-player-board spot) )
	( (eq spot 'sB ) (setf (board-s11 b) 's) (update-other-player-board spot) )
	( (eq spot 'sC ) (setf (board-s12 b) 's) (update-other-player-board spot) )
	( (eq spot 'sD ) (setf (board-s13 b) 's) (update-other-player-board spot) )
	( (eq spot 'sE ) (setf (board-s14 b) 's) (update-other-player-board spot) )
	( (eq spot 'sF ) (setf (board-s15 b) 's) (update-other-player-board spot) )
	( (eq spot 'sG ) (setf (board-s16 b) 's) (update-other-player-board spot) )
 )
)

;;remove from board at random
( defmethod remove-from-board-r-p ((b board)(p player)(s symbol))
 ( cond
   ( (three-in-a-row-w b s)  
    ( remove-piece-from-board-r b p ) )
   ( (three-in-a-row-b b s)
    ( remove-piece-from-board-r b p )	)
 )
)

;;select piece method for random player
( defmethod select-piece-r () 
 (setf p *current-pieces*)
 (nth (random (length p)) p)
)

;;place random piece on random spot
( defmethod place-piece-on-board-r ( (s symbol) (b board) &aux spot )
 ( setf spot (select-spot-r b) )
 ( put-piece spot s b )
 ( remove-piece-from-set s )
 ( remove-from-board-r-p (state-board (game-state g) ) (other-player g) spot )
)

;;make move for random player
( defmethod make-move-r ((g game))
 ( display-current-piece-set )
 ( setf piece (select-piece-r) )
 ( place-piece-on-board-r piece ( state-board (game-state g) ) )
 nil
)

;;phase-2 random machine
( defmethod phase-2-r ( (g game) ) 
 ( display-current-player-board )
 ( setf spot1 (select-used-spot (state-board (game-state g) ) ) )
 ( setf spot2 (select-adjacent-spot spot1 (state-board (game-state g)) ) )
 ( format t "Select a spot to slide from " ) ( format t "~A~%" spot1 )
 ( format t "Select a spot to slide to " ) ( format t "~A~%" spot2 )
	  ( slide-piece spot1 spot2 (state-board (game-state g) ) )
	  ( remove-from-board-r-p (state-board (game-state g) ) (other-player g) spot2 )
	  ( update-player-board spot1 spot2 )
)

;;random player move
( defmethod move-r ( (g game) )
 ( make-move-r g )
 ( change-piece-set )
 ( change-player g )
)

;;phase 2 moves for random player
( defmethod move-phase2-r ( (g game) )
 ( phase-2-r g )
 ( change-player-board )
 ( change-player g )
)

;;play phase 2 method for random player
( defmethod play-phase2-r ( (g game) )
( format t "Entering Phase 2...~%" )
( set-used-spots (state-board (game-state g) ) )
( setf *current-player-board* *used-spots-w* )
 ( loop
    ( terpri )
	( display-board (state-board (game-state g) ) )
	( terpri )
	( if ( game-over-p g)
	     ( return-from play-phase2-r (end-game g) )
		 ( move-phase2-r g )
	)	
 )
)

;;play method for random player
( defmethod play-r ( ( g game ) )
 ( loop
  ( terpri )
  ( display-board ( state-board ( game-state g ) ) )
  ( terpri )
  ( move-r g )
  ( cond 
   ( ( all-pieces-used )
     ( return-from play-r(play-phase2-r g))
   )
  )
 )
)

;;random vs random game
( defmethod r-r-game()
 ( establish-pieces )
 ( setf *wavail* (all-to-string *wpieces*) )
 ( setf *bavail* (all-to-string *bpieces*) )
 ( setf *current-pieces* *wavail* )
 ( let (state player1 player2 name1 name2 first initial-state game)
   (setf name1 'testdummy1 ) (setf name2 'testdummy2 )
   (format t "Player 1 Name is ~A ~&" name1) 
   (format t "Player 2 Name is ~A ~%" name2)  
	(setf player1 (make-instance 'r-machine-player :name name1) )
	(setf player2 (make-instance 'r-machine-player :name name2) )
	(setf first (pick-first-player player1 player2) )
	(format t "~A , You get to go first ~%" (player-name first) )
	(setf initial-state (make-instance 'state :player first) )
	(make-instance 'game 
	  :state initial-state :player1 player1 :player2 player2)
 )
)

;;demo r-r game
( defmethod play-r-demo ()
 ( setf g (r-r-game) )
 ( play-r g )
)

;;------------------------------------------------------------------Heuristic Machine--------------------------------------------------------------------------

;;check available spots for possible three in a row for player2
;;if player doesnt have two in a row or third spot isnt available then a random available spot is selected
( defmethod two-in-a-row-b ((b board) &aux spot )
 ( cond
  ( ( and (eq (board-s1 b) 'b ) (eq (board-s2 b) 'b ) (eq (board-s3 b) 's) ) (setf spot 's3 ) )
  ( ( and (eq (board-s1 b) 'b ) (eq (board-s3 b) 'b ) (eq (board-s2 b) 's) ) (setf spot 's2 ) )
  ( ( and (eq (board-s1 b) 'b ) (eq (board-s8 b) 'b ) (eq (board-s7 b) 's) ) (setf spot 's7 ) )
  ( ( and (eq (board-s2 b) 'b ) (eq (board-s3 b) 'b ) (eq (board-s1 b) 's) ) (setf spot 's1 ) )
  ( ( and (eq (board-s3 b) 'b ) (eq (board-s4 b) 'b ) (eq (board-s5 b) 's) ) (setf spot 's5 ) )
  ( ( and (eq (board-s3 b) 'b ) (eq (board-s5 b) 'b ) (eq (board-s4 b) 's) ) (setf spot 's4 ) )
  ( ( and (eq (board-s4 b) 'b ) (eq (board-s5 b) 'b ) (eq (board-s3 b) 's) ) (setf spot 's3 ) )
  ( ( and (eq (board-s5 b) 'b ) (eq (board-s6 b) 'b ) (eq (board-s7 b) 's) ) (setf spot 's7 ) )
  ( ( and (eq (board-s5 b) 'b ) (eq (board-s7 b) 'b ) (eq (board-s6 b) 's) ) (setf spot 's6 ) )
  ( ( and (eq (board-s6 b) 'b ) (eq (board-s7 b) 'b ) (eq (board-s5 b) 's) ) (setf spot 's5 ) )
  ( ( and (eq (board-s7 b) 'b ) (eq (board-s8 b) 'b ) (eq (board-s1 b) 's) ) (setf spot 's1 ) )
  ( ( and (eq (board-s7 b) 'b ) (eq (board-s1 b) 'b ) (eq (board-s8 b) 's) ) (setf spot 's8 ) )
  ( ( and (eq (board-s9 b) 'b ) (eq (board-s10 b) 'b ) (eq (board-s16 b) 's) ) (setf spot 'sG ) )
  ( ( and (eq (board-s9 b) 'b ) (eq (board-s16 b) 'b ) (eq (board-s10 b) 's) ) (setf spot 'sA ) )
  ( ( and (eq (board-s10 b) 'b ) (eq (board-s16 b) 'b ) (eq (board-s9 b) 's) ) (setf spot 's9 ) )
  ( ( and (eq (board-s10 b) 'b ) (eq (board-s11 b) 'b ) (eq (board-s12 b) 's) ) (setf spot 'sC ) )
  ( ( and (eq (board-s10 b) 'b ) (eq (board-s12 b) 'b ) (eq (board-s11 b) 's) ) (setf spot 'sB ) )
  ( ( and (eq (board-s11 b) 'b ) (eq (board-s12 b) 'b ) (eq (board-s10 b) 's) ) (setf spot 'sA ) )
  ( ( and (eq (board-s12 b) 'b ) (eq (board-s13 b) 'b ) (eq (board-s14 b) 's) ) (setf spot 'sE ) )
  ( ( and (eq (board-s12 b) 'b ) (eq (board-s14 b) 'b ) (eq (board-s13 b) 's) ) (setf spot 'sD ) )
  ( ( and (eq (board-s13 b) 'b ) (eq (board-s14 b) 'b ) (eq (board-s12 b) 's) ) (setf spot 'sC ) )
  ( ( and (eq (board-s14 b) 'b ) (eq (board-s15 b) 'b ) (eq (board-s16 b) 's) ) (setf spot 'sG ) )
  ( ( and (eq (board-s14 b) 'b ) (eq (board-s16 b) 'b ) (eq (board-s15 b) 's) ) (setf spot 'sF ) )
  ( ( and (eq (board-s15 b) 'b ) (eq (board-s16 b) 'b ) (eq (board-s14 b) 's) ) (setf spot 'sE ) )
 )
 spot
)

;;check to see if block is available for player1
( defmethod possible-block-w ((b board))
 (format t "Looking to block opponent from getting three in a row~%")
 ( cond
  ( ( and (eq (board-s1 b) 'b ) (eq (board-s2 b) 'b ) (eq (board-s3 b) 's) ) t )
  ( ( and (eq (board-s1 b) 'b ) (eq (board-s3 b) 'b ) (eq (board-s2 b) 's) ) t )
  ( ( and (eq (board-s1 b) 'b ) (eq (board-s8 b) 'b ) (eq (board-s7 b) 's) ) t )
  ( ( and (eq (board-s2 b) 'b ) (eq (board-s3 b) 'b ) (eq (board-s1 b) 's) ) t )
  ( ( and (eq (board-s3 b) 'b ) (eq (board-s4 b) 'b ) (eq (board-s5 b) 's) ) t )
  ( ( and (eq (board-s3 b) 'b ) (eq (board-s5 b) 'b ) (eq (board-s4 b) 's) ) t )
  ( ( and (eq (board-s4 b) 'b ) (eq (board-s5 b) 'b ) (eq (board-s3 b) 's) ) t )
  ( ( and (eq (board-s5 b) 'b ) (eq (board-s6 b) 'b ) (eq (board-s7 b) 's) ) t )
  ( ( and (eq (board-s5 b) 'b ) (eq (board-s7 b) 'b ) (eq (board-s6 b) 's) ) t )
  ( ( and (eq (board-s6 b) 'b ) (eq (board-s7 b) 'b ) (eq (board-s5 b) 's) ) t )
  ( ( and (eq (board-s7 b) 'b ) (eq (board-s8 b) 'b ) (eq (board-s1 b) 's) ) t )
  ( ( and (eq (board-s7 b) 'b ) (eq (board-s1 b) 'b ) (eq (board-s8 b) 's) ) t )
  ( ( and (eq (board-s9 b) 'b ) (eq (board-s10 b) 'b ) (eq (board-s16 b) 's) ) t )
  ( ( and (eq (board-s9 b) 'b ) (eq (board-s16 b) 'b ) (eq (board-s10 b) 's) ) t )
  ( ( and (eq (board-s10 b) 'b ) (eq (board-s16 b) 'b ) (eq (board-s9 b) 's) ) t )
  ( ( and (eq (board-s10 b) 'b ) (eq (board-s11 b) 'b ) (eq (board-s12 b) 's) ) t )
  ( ( and (eq (board-s10 b) 'b ) (eq (board-s12 b) 'b ) (eq (board-s11 b) 's) ) t )
  ( ( and (eq (board-s11 b) 'b ) (eq (board-s12 b) 'b ) (eq (board-s10 b) 's) ) t )
  ( ( and (eq (board-s12 b) 'b ) (eq (board-s13 b) 'b ) (eq (board-s14 b) 's) ) t )
  ( ( and (eq (board-s12 b) 'b ) (eq (board-s14 b) 'b ) (eq (board-s13 b) 's) ) t )
  ( ( and (eq (board-s13 b) 'b ) (eq (board-s14 b) 'b ) (eq (board-s12 b) 's) ) t )
  ( ( and (eq (board-s14 b) 'b ) (eq (board-s15 b) 'b ) (eq (board-s16 b) 's) ) t )
  ( ( and (eq (board-s14 b) 'b ) (eq (board-s16 b) 'b ) (eq (board-s15 b) 's) ) t )
  ( ( and (eq (board-s15 b) 'b ) (eq (board-s16 b) 'b ) (eq (board-s14 b) 's) ) t )
 )
)

;;check to see if block is available for player2
( defmethod possible-block-b ((b board))
 (format t "Looking to block opponent from getting three in a row~%")
 ( cond
  ( ( and (eq (board-s1 b) 'w ) (eq (board-s2 b) 'w ) (eq (board-s3 b) 's) ) t )
  ( ( and (eq (board-s1 b) 'w ) (eq (board-s3 b) 'w ) (eq (board-s2 b) 's) ) t )
  ( ( and (eq (board-s1 b) 'w ) (eq (board-s8 b) 'w ) (eq (board-s7 b) 's) ) t )
  ( ( and (eq (board-s2 b) 'w ) (eq (board-s3 b) 'w ) (eq (board-s1 b) 's) ) t )
  ( ( and (eq (board-s3 b) 'w ) (eq (board-s4 b) 'w ) (eq (board-s5 b) 's) ) t )
  ( ( and (eq (board-s3 b) 'w ) (eq (board-s5 b) 'w ) (eq (board-s4 b) 's) ) t )
  ( ( and (eq (board-s4 b) 'w ) (eq (board-s5 b) 'w ) (eq (board-s3 b) 's) ) t )
  ( ( and (eq (board-s5 b) 'w ) (eq (board-s6 b) 'w ) (eq (board-s7 b) 's) ) t )
  ( ( and (eq (board-s5 b) 'w ) (eq (board-s7 b) 'w ) (eq (board-s6 b) 's) ) t )
  ( ( and (eq (board-s6 b) 'w ) (eq (board-s7 b) 'w ) (eq (board-s5 b) 's) ) t )
  ( ( and (eq (board-s7 b) 'w ) (eq (board-s8 b) 'w ) (eq (board-s1 b) 's) ) t )
  ( ( and (eq (board-s7 b) 'w ) (eq (board-s1 b) 'w ) (eq (board-s8 b) 's) ) t )
  ( ( and (eq (board-s9 b) 'w ) (eq (board-s10 b) 'w ) (eq (board-s16 b) 's) ) t )
  ( ( and (eq (board-s9 b) 'w ) (eq (board-s16 b) 'w ) (eq (board-s10 b) 's) ) t )
  ( ( and (eq (board-s10 b) 'w ) (eq (board-s16 b) 'w ) (eq (board-s9 b) 's) ) t )
  ( ( and (eq (board-s10 b) 'w ) (eq (board-s11 b) 'w ) (eq (board-s12 b) 's) ) t )
  ( ( and (eq (board-s10 b) 'w ) (eq (board-s12 b) 'w ) (eq (board-s11 b) 's) ) t )
  ( ( and (eq (board-s11 b) 'w ) (eq (board-s12 b) 'w ) (eq (board-s10 b) 's) ) t )
  ( ( and (eq (board-s12 b) 'w ) (eq (board-s13 b) 'w ) (eq (board-s14 b) 's) ) t )
  ( ( and (eq (board-s12 b) 'w ) (eq (board-s14 b) 'w ) (eq (board-s13 b) 's) ) t )
  ( ( and (eq (board-s13 b) 'w ) (eq (board-s14 b) 'w ) (eq (board-s12 b) 's) ) t )
  ( ( and (eq (board-s14 b) 'w ) (eq (board-s15 b) 'w ) (eq (board-s16 b) 's) ) t )
  ( ( and (eq (board-s14 b) 'w ) (eq (board-s16 b) 'w ) (eq (board-s15 b) 's) ) t )
  ( ( and (eq (board-s15 b) 'w ) (eq (board-s16 b) 'w ) (eq (board-s14 b) 's) ) t )
 )
)

;;check to see if three in a row is available for player2
( defmethod possible-row-b ((b board))
 (format t "Looking to complete three in a row~%")
 ( cond
  ( ( and (eq (board-s1 b) 'b ) (eq (board-s2 b) 'b ) (eq (board-s3 b) 's) ) t )
  ( ( and (eq (board-s1 b) 'b ) (eq (board-s3 b) 'b ) (eq (board-s2 b) 's) ) t )
  ( ( and (eq (board-s1 b) 'b ) (eq (board-s8 b) 'b ) (eq (board-s7 b) 's) ) t )
  ( ( and (eq (board-s2 b) 'b ) (eq (board-s3 b) 'b ) (eq (board-s1 b) 's) ) t )
  ( ( and (eq (board-s3 b) 'b ) (eq (board-s4 b) 'b ) (eq (board-s5 b) 's) ) t )
  ( ( and (eq (board-s3 b) 'b ) (eq (board-s5 b) 'b ) (eq (board-s4 b) 's) ) t )
  ( ( and (eq (board-s4 b) 'b ) (eq (board-s5 b) 'b ) (eq (board-s3 b) 's) ) t )
  ( ( and (eq (board-s5 b) 'b ) (eq (board-s6 b) 'b ) (eq (board-s7 b) 's) ) t )
  ( ( and (eq (board-s5 b) 'b ) (eq (board-s7 b) 'b ) (eq (board-s6 b) 's) ) t )
  ( ( and (eq (board-s6 b) 'b ) (eq (board-s7 b) 'b ) (eq (board-s5 b) 's) ) t )
  ( ( and (eq (board-s7 b) 'b ) (eq (board-s8 b) 'b ) (eq (board-s1 b) 's) ) t )
  ( ( and (eq (board-s7 b) 'b ) (eq (board-s1 b) 'b ) (eq (board-s8 b) 's) ) t )
  ( ( and (eq (board-s9 b) 'b ) (eq (board-s10 b) 'b ) (eq (board-s16 b) 's) ) t )
  ( ( and (eq (board-s9 b) 'b ) (eq (board-s16 b) 'b ) (eq (board-s10 b) 's) ) t )
  ( ( and (eq (board-s10 b) 'b ) (eq (board-s16 b) 'b ) (eq (board-s9 b) 's) ) t )
  ( ( and (eq (board-s10 b) 'b ) (eq (board-s11 b) 'b ) (eq (board-s12 b) 's) ) t )
  ( ( and (eq (board-s10 b) 'b ) (eq (board-s12 b) 'b ) (eq (board-s11 b) 's) ) t )
  ( ( and (eq (board-s11 b) 'b ) (eq (board-s12 b) 'b ) (eq (board-s10 b) 's) ) t )
  ( ( and (eq (board-s12 b) 'b ) (eq (board-s13 b) 'b ) (eq (board-s14 b) 's) ) t )
  ( ( and (eq (board-s12 b) 'b ) (eq (board-s14 b) 'b ) (eq (board-s13 b) 's) ) t )
  ( ( and (eq (board-s13 b) 'b ) (eq (board-s14 b) 'b ) (eq (board-s12 b) 's) ) t )
  ( ( and (eq (board-s14 b) 'b ) (eq (board-s15 b) 'b ) (eq (board-s16 b) 's) ) t )
  ( ( and (eq (board-s14 b) 'b ) (eq (board-s16 b) 'b ) (eq (board-s15 b) 's) ) t )
  ( ( and (eq (board-s15 b) 'b ) (eq (board-s16 b) 'b ) (eq (board-s14 b) 's) ) t )
  ( t (format t "Three in a row cannot be achieved...~%") )
 )
)

;;check to see if three in a row is available for player1
( defmethod possible-row-w ((b board))
 (format t "Looking to complete three in a row~%")
 ( cond
  ( ( and (eq (board-s1 b) 'w ) (eq (board-s2 b) 'w ) (eq (board-s3 b) 's) ) t )
  ( ( and (eq (board-s1 b) 'w ) (eq (board-s3 b) 'w ) (eq (board-s2 b) 's) ) t )
  ( ( and (eq (board-s1 b) 'w ) (eq (board-s8 b) 'w ) (eq (board-s7 b) 's) ) t )
  ( ( and (eq (board-s2 b) 'w ) (eq (board-s3 b) 'w ) (eq (board-s1 b) 's) ) t )
  ( ( and (eq (board-s3 b) 'w ) (eq (board-s4 b) 'w ) (eq (board-s5 b) 's) ) t )
  ( ( and (eq (board-s3 b) 'w ) (eq (board-s5 b) 'w ) (eq (board-s4 b) 's) ) t )
  ( ( and (eq (board-s4 b) 'w ) (eq (board-s5 b) 'w ) (eq (board-s3 b) 's) ) t )
  ( ( and (eq (board-s5 b) 'w ) (eq (board-s6 b) 'w ) (eq (board-s7 b) 's) ) t )
  ( ( and (eq (board-s5 b) 'w ) (eq (board-s7 b) 'w ) (eq (board-s6 b) 's) ) t )
  ( ( and (eq (board-s6 b) 'w ) (eq (board-s7 b) 'w ) (eq (board-s5 b) 's) ) t )
  ( ( and (eq (board-s7 b) 'w ) (eq (board-s8 b) 'w ) (eq (board-s1 b) 's) ) t )
  ( ( and (eq (board-s7 b) 'w ) (eq (board-s1 b) 'w ) (eq (board-s8 b) 's) ) t )
  ( ( and (eq (board-s9 b) 'w ) (eq (board-s10 b) 'w ) (eq (board-s16 b) 's) ) t )
  ( ( and (eq (board-s9 b) 'w ) (eq (board-s16 b) 'w ) (eq (board-s10 b) 's) ) t )
  ( ( and (eq (board-s10 b) 'w ) (eq (board-s16 b) 'w ) (eq (board-s9 b) 's) ) t )
  ( ( and (eq (board-s10 b) 'w ) (eq (board-s11 b) 'w ) (eq (board-s12 b) 's) ) t )
  ( ( and (eq (board-s10 b) 'w ) (eq (board-s12 b) 'w ) (eq (board-s11 b) 's) ) t )
  ( ( and (eq (board-s11 b) 'w ) (eq (board-s12 b) 'w ) (eq (board-s10 b) 's) ) t )
  ( ( and (eq (board-s12 b) 'w ) (eq (board-s13 b) 'w ) (eq (board-s14 b) 's) ) t )
  ( ( and (eq (board-s12 b) 'w ) (eq (board-s14 b) 'w ) (eq (board-s13 b) 's) ) t )
  ( ( and (eq (board-s13 b) 'w ) (eq (board-s14 b) 'w ) (eq (board-s12 b) 's) ) t )
  ( ( and (eq (board-s14 b) 'w ) (eq (board-s15 b) 'w ) (eq (board-s16 b) 's) ) t )
  ( ( and (eq (board-s14 b) 'w ) (eq (board-s16 b) 'w ) (eq (board-s15 b) 's) ) t )
  ( ( and (eq (board-s15 b) 'w ) (eq (board-s16 b) 'w ) (eq (board-s14 b) 's) ) t )
  ( t (format t "Three in a row cannot be achieved...~%") )
 )
)

;;check available spots for possible three in a row for player1
;;if player doesnt have two in a row or third spot isnt available then a random available spot is selected
( defmethod two-in-a-row-w ((b board) &aux spot )
 ( cond
  ( ( and (eq (board-s1 b) 'w ) (eq (board-s2 b) 'w ) (eq (board-s3 b) 's) ) (setf spot 's3 ) )
  ( ( and (eq (board-s1 b) 'w ) (eq (board-s3 b) 'w ) (eq (board-s2 b) 's) ) (setf spot 's2 ) )
  ( ( and (eq (board-s1 b) 'w ) (eq (board-s8 b) 'w ) (eq (board-s7 b) 's) ) (setf spot 's7 ) )
  ( ( and (eq (board-s2 b) 'w ) (eq (board-s3 b) 'w ) (eq (board-s1 b) 's) ) (setf spot 's1 ) )
  ( ( and (eq (board-s3 b) 'w ) (eq (board-s4 b) 'w ) (eq (board-s5 b) 's) ) (setf spot 's5 ) )
  ( ( and (eq (board-s3 b) 'w ) (eq (board-s5 b) 'w ) (eq (board-s4 b) 's) ) (setf spot 's4 ) )
  ( ( and (eq (board-s4 b) 'w ) (eq (board-s5 b) 'w ) (eq (board-s3 b) 's) ) (setf spot 's3 ) )
  ( ( and (eq (board-s5 b) 'w ) (eq (board-s6 b) 'w ) (eq (board-s7 b) 's) ) (setf spot 's7 ) )
  ( ( and (eq (board-s5 b) 'w ) (eq (board-s7 b) 'w ) (eq (board-s6 b) 's) ) (setf spot 's6 ) )
  ( ( and (eq (board-s6 b) 'w ) (eq (board-s7 b) 'w ) (eq (board-s5 b) 's) ) (setf spot 's5 ) )
  ( ( and (eq (board-s7 b) 'w ) (eq (board-s8 b) 'w ) (eq (board-s1 b) 's) ) (setf spot 's1 ) )
  ( ( and (eq (board-s7 b) 'w ) (eq (board-s1 b) 'w ) (eq (board-s8 b) 's) ) (setf spot 's8 ) )
  ( ( and (eq (board-s9 b) 'w ) (eq (board-s10 b) 'w ) (eq (board-s16 b) 's) ) (setf spot 'sG ) )
  ( ( and (eq (board-s9 b) 'w ) (eq (board-s16 b) 'w ) (eq (board-s10 b) 's) ) (setf spot 'sA ) )
  ( ( and (eq (board-s10 b) 'w ) (eq (board-s16 b) 'w ) (eq (board-s9 b) 's) ) (setf spot 's9 ) )
  ( ( and (eq (board-s10 b) 'w ) (eq (board-s11 b) 'w ) (eq (board-s12 b) 's) ) (setf spot 'sC ) )
  ( ( and (eq (board-s10 b) 'w ) (eq (board-s12 b) 'w ) (eq (board-s11 b) 's) ) (setf spot 'sB ) )
  ( ( and (eq (board-s11 b) 'w ) (eq (board-s12 b) 'w ) (eq (board-s10 b) 's) ) (setf spot 'sA ) )
  ( ( and (eq (board-s12 b) 'w ) (eq (board-s13 b) 'w ) (eq (board-s14 b) 's) ) (setf spot 'sE ) )
  ( ( and (eq (board-s12 b) 'w ) (eq (board-s14 b) 'w ) (eq (board-s13 b) 's) ) (setf spot 'sD ) )
  ( ( and (eq (board-s13 b) 'w ) (eq (board-s14 b) 'w ) (eq (board-s12 b) 's) ) (setf spot 'sC ) )
  ( ( and (eq (board-s14 b) 'w ) (eq (board-s15 b) 'w ) (eq (board-s16 b) 's) ) (setf spot 'sG ) )
  ( ( and (eq (board-s14 b) 'w ) (eq (board-s16 b) 'w ) (eq (board-s15 b) 's) ) (setf spot 'sF ) )
  ( ( and (eq (board-s15 b) 'w ) (eq (board-s16 b) 'w ) (eq (board-s14 b) 's) ) (setf spot 'sE ) )
 )
 spot
)

;;place piece on spot given heuristics
( defmethod place-piece-on-board-h ( (s symbol) (g game) &aux spot )
 (cond
	( (equal-player (state-player (game-state g)) (game-player1 g))
		(cond 
		   ((possible-row-w ( state-board (game-state g) ))
			(setf spot (two-in-a-row-w ( state-board (game-state g) )))
			(format t "Place piece at spot ~A to complete three in a row~%" spot)
		   )
		   ((possible-block-w ( state-board (game-state g) ) )
		    (setf spot (two-in-a-row-b (state-board (game-state g))))
			(format t "Place piece at spot ~A to block opponent~%" spot)
		   )
		   (t
		    (format t "Could not achieve three in a row nor block...randomly picking spot~%")
			(setf spot (select-spot-r (state-board (game-state g))))
		   )
		) 
	)
	( (equal-player (state-player (game-state g)) (game-player2 g))
		(cond 
		   ((possible-row-b ( state-board (game-state g) ))
			(setf spot (two-in-a-row-w ( state-board (game-state g) )))
			(format t "Place piece at spot ~A to complete three in a row~%" spot)
		   )
		   ((possible-block-b ( state-board (game-state g) ) )
		    (setf spot (two-in-a-row-w (state-board (game-state g))))
			(format t "Place piece at spot ~A to block opponent~%" spot)
		   )
		   (t
		    (format t "Could not achieve three in a row nor block...randomly picking spot~%")
			(setf spot (select-spot-r (state-board (game-state g))))
		   )
		) 
	)
 )
 ( put-piece spot s ( state-board (game-state g) ) )
 ( remove-piece-from-set s )
)

;;make move for heuristic player
( defmethod make-move-h ( (g game) )
 ( display-current-piece-set )
 ( setf piece (select-piece-r) )
 ( place-piece-on-board-h piece g )
 nil
)

;;heuristic player move
( defmethod move-h ( (g game) )
 ( make-move-h g )
 ( change-piece-set )
 ( change-player g )
)

;;play method for heuristic player
( defmethod play-h ( ( g game ) )
 ( loop
  ( terpri )
  ( display-board ( state-board ( game-state g ) ) )
  ( terpri )
  ( move-h g )
  ( cond 
   ( ( all-pieces-used )
     ( return-from play-h(play-phase2-r g))
   )
  )
 )
)

;;heuristic vs heuristic game
( defmethod h-game()
 ( establish-pieces )
 ( setf *wavail* (all-to-string *wpieces*) )
 ( setf *bavail* (all-to-string *bpieces*) )
 ( setf *current-pieces* *wavail* )
 ( let (state player1 player2 name1 name2 first initial-state game)
   (setf name1 'testdummy1 ) (setf name2 'testdummy2 )
   (format t "Player 1 Name is ~A ~&" name1) 
   (format t "Player 2 Name is ~A ~%" name2)  
	(setf player1 (make-instance 'h-machine-player :name name1) )
	(setf player2 (make-instance 'h-machine-player :name name2) )
	(setf first (pick-first-player player1 player2) )
	(format t "~A , You get to go first ~%" (player-name first) )
	(setf initial-state (make-instance 'state :player first) )
	(make-instance 'game 
	  :state initial-state :player1 player1 :player2 player2)
 )
)

;;demo heuristic game
( defmethod play-h-demo ()
 ( setf g (h-game) )
 ( play-h g )
)

;;------------------------------------------------------Show Results--------------------------------------------------------------------------------
( defmethod h-vs-random ()
 ( establish-pieces )
 ( setf *wavail* (all-to-string *wpieces*) )
 ( setf *bavail* (all-to-string *bpieces*) )
 ( setf *current-pieces* *wavail* )
 ( let (state player1 player2 name1 name2 first initial-state game)
   (setf name1 'testdummy1 ) (setf name2 'testdummy2 )
   (format t "Player 1 Name is ~A ~&" name1) 
   (format t "Player 2 Name is ~A ~%" name2)  
	(setf player1 (make-instance 'h-machine-player :name name1) )
	(setf player2 (make-instance 'r-machine-player :name name2) )
	(setf first player1)
	(format t "~A , You get to go first ~%" (player-name first) )
	(setf initial-state (make-instance 'state :player first) )
	(make-instance 'game 
	  :state initial-state :player1 player1 :player2 player2)
 )
)

( defmethod ppobh1 ((s symbol)(g game) &aux spot )
 (cond 
	((possible-block-w ( state-board (game-state g) ) )
         (setf spot (two-in-a-row-b (state-board (game-state g))))
	 (format t "Place piece at spot ~A to block opponent~%" spot)
	)
	(t
	 (format t "Could not block...randomly picking spot~%")
	 (setf spot (select-spot-r (state-board (game-state g))))
	)
 )
 ( put-piece spot s ( state-board (game-state g) ) )
 ( remove-piece-from-set s ) 
)

( defmethod ppobh2 ((s symbol)(g game) &aux spot )
 (cond 
	((possible-row-w ( state-board (game-state g) ) )
         (setf spot (two-in-a-row-w (state-board (game-state g))))
	 (format t "Place piece at spot ~A to block opponent~%" spot)
	)
	(t
	 (format t "Could not block...randomly picking spot~%")
	 (setf spot (select-spot-r (state-board (game-state g))))
	)
 )
 ( put-piece spot s ( state-board (game-state g) ) )
 ( remove-piece-from-set s ) 
)

( defmethod end-game-result ( (g game) )
 ( setf p (other-player g) )
 ( format t "Congratulations ~A, You are the WINNER!~%" (player-name p) )
 ( player-name p )
)

( defmethod play-h1vr ( ( g game ) )
 ( loop
  ( move-h1vr g )
  ( cond 
   ( ( all-pieces-used )
     ( return-from play-h1vr(play-phase2-r g))
   )
  )
 )
)

( defmethod play-h2vr ( ( g game ) )
 ( loop
  ( move-h2vr g )
  ( cond 
   ( ( all-pieces-used )
     ( return-from play-h2vr(play-phase2-r g))
   )
  )
 )
)

( defmethod make-move-h1vr ( (g game) )
 ( setf piece (select-piece-r) )
 (if (equal-player (state-player (game-state g)) (game-player1 g))
     (ppobh1 piece g)
     (place-piece-on-board-r piece ( state-board (game-state g) ))
 )
 nil
)

( defmethod make-move-h2vr ( (g game) )
 ( setf piece (select-piece-r) )
 (if (equal-player (state-player (game-state g)) (game-player1 g))
     (ppobh2 piece g)
     (place-piece-on-board-r piece ( state-board (game-state g) ))
 )
 nil
)

( defmethod move-h1vr ( (g game) )
 ( make-move-h1vr g )
 ( change-piece-set )
 ( change-player g )
)

( defmethod move-h2vr ( (g game) )
 ( make-move-h2vr g )
 ( change-piece-set )
 ( change-player g )
)

( defmethod play-game-h1vr (&aux result)
 (setf g (h-vs-random) )
 (play-h1vr g)
 (if (equal (end-game-result g) 'testdummy1) 
     (setf result 'w) 
     (setf result 'l)
 )
 result
)

( defmethod play-game-h2vr (&aux result)
 (setf g (h-vs-random) )
 (play-h2vr g)
 (if (equal (end-game-result g) 'testdummy1) 
     (setf result 'w) 
     (setf result 'l)
 )
 result
)

(defmethod show-results ((i integer) &aux c1 c2 value1 value2)
 (setf c1 0)
 (setf c2 0)
 (dotimes (n i)
  (if (equal (play-game-h1vr) 'w) (setf c1 (+ c1 1))) 
  (if (equal (play-game-h2vr) 'w) (setf c2 (+ c2 1))) 
 )
 (setf value1 (float (* 100 (/ c1 i) ) ) )
 (setf value2 (float (* 100 (/ c2 i) ) ) )
 (format t "Out of ~A attempts, the results show~%" i)
 (format t "heuristic player 1(block first) won ~A games, a success rate of: ~A%~%" c1 value1)
 (format t "heuristic player 2(row first) won ~A games, a success rate of: ~A%~%" c2 value2)
)
